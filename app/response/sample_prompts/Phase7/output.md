了解しました。フェーズ7「SSLピンニングのバイパス（セキュリティテスト目的）」に関する解説資料を、専門的かつ丁寧に作成します。

Frida、Objection、Burp Suite、アプリ改変といった代表的な手法について、実践的かつ理論的な説明を画像や図を交えて日本語で構成します。倫理的背景や使用上の注意点も含めて、情報系の大学院生レベルを想定して、専門用語の省略なしで解説します。

完成したらお知らせします！

## フェーズ7 
1. **バイパスの目的と倫理**  
   - **正当な利用目的:** SSLピンニング（証明書ピン留め）は本来、クライアントアプリが接続先サーバの証明書を事前にアプリ内に登録し、それと照合することで信頼性を担保する仕組みです ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=The%20developer%20configures%20SSL%20pinning,the%20pinned%20certificate%20match))。しかしセキュリティテストやアプリ開発の場面では、この仕組みがテスターや開発者による通信内容の検証を妨げることがあります。たとえばモバイルアプリの脆弱性診断では、通信を傍受・解析して機密データ漏洩や不適切な実装をチェックしますが、ピンニングによってプロキシツール（Burp SuiteやOWASP ZAPなど）の自己署名証明書を受け入れず通信を拒否してしまいます ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=Why%20do%20we%20need%20to,of%20connecting%20over%20a%20potentially))。そのため**動的解析を開始する前段階としてSSLピンニングのバイパスが必要不可欠**です ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=Because%20organizations%20are%20more%20concerned,for%20most%20mobile%20applications%20nowadays))。実際、モバイルアプリのペンテストでは攻撃者がまずこの保護層を突破しようとするため、防御側もそれを見越した十分なテストが求められます ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=The%20amount%20of%20private%20and,stay%20ahead%20of%20the%20attackers))。開発時にも、一時的にピンニングを無効化して通信内容をデバッグしたり、サーバAPIの動作検証を行うケースがあります。以上のように、**自社アプリの検証や許可を得た正当なセキュリティ目的**であればピンニングのバイパスは必要な手段となります。  
   - **倫理的配慮と注意点:** SSLピンニングのバイパス行為は、本質的にアプリのセキュリティ機構を意図的に無効化する行為です。不正な目的で使用すれば盗聴や改ざんを可能にするため、**倫理的に許されるのは自分が権限を持つアプリや環境に対してのみ**です。他人のアプリやサービスに無断で適用することは利用規約違反や法律違反（不正アクセス行為など）に該当する恐れがあります。実際に筆者も社内の脆弱性診断でやむを得ずピンニングをバイパスした経験をまとめていますが、その冒頭でも「**悪用しないようにお願いします**」と注意喚起しています ([〖Windows10〗証明書ピンニングのバイパスしつつAndroidアプリの脆弱性診断 #frida - Qiita](https://qiita.com/toubaru/items/c8489c6604fe9b030d41#:~:text=%E8%84%86%E5%BC%B1%E6%80%A7%E8%A8%BA%E6%96%AD%E3%81%97%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E8%A8%BC%E6%98%8E%E6%9B%B8%E3%83%94%E3%83%B3%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%A7API%E3%81%AE%E8%A8%BA%E6%96%AD%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%82%A2%E3%83%97%E3%83%AA%E3%81%8C%E3%81%82%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%8C%E3%81%8D%E3%81%A3%E3%81%8B%E3%81%91%E3%81%A7%E3%81%99%E3%80%82%20%E8%A8%BC%E6%98%8E%E6%9B%B8%E3%83%94%E3%83%B3%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%AE%E8%A7%A3%E9%99%A4%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%9F%E3%82%81%E3%83%90%E3%82%A4%E3%83%91%E3%82%B9%E6%89%8B%E6%AE%B5%E3%82%92%E6%8E%A2%E3%81%97%E3%81%A6%E7%84%A1%E7%90%86%E3%82%84%E3%82%8A%E8%A8%BA%E6%96%AD%E3%81%97%E3%81%9F%E6%99%82%E3%81%AE%E6%89%8B%E9%A0%86%E3%81%AE%E7%BA%8F%E3%82%81%E3%81%A7%E3%81%99%E3%80%82%20%E5%9F%BA%E6%9C%AC%E3%81%AFMac%E3%81%A7%E3%82%82%E5%90%8C%E3%81%98%E3%81%A7%E3%80%81%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E9%81%A9%E5%AE%9C%E5%A4%89%E3%81%88%E3%82%8C%E3%81%B0%E8%A1%8C%E3%81%91%E3%82%8B%E3%81%AF%E3%81%9A%E3%81%A7%E3%81%99%E3%80%82%20iOS%E3%81%AF%E6%9C%AA%E6%A4%9C%E8%A8%BC%E3%81%A7%E3%81%99%E3%80%82%20%E6%82%AA%E7%94%A8%E3%81%97%E3%81%AA%E3%81%84%E3%82%88%E3%81%86%E3%81%AB%E3%81%8A%E9%A1%98%E3%81%84%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。バイパス実施時にはテスト対象範囲を守り、取得したデータの取り扱いにも最新の注意を払いましょう。また、ピンニングはユーザの通信を守るためのものですので、テスト後は必要に応じて元のセキュリティ設定に戻すことも大切です。

2. **バイパス手法の概要**  
   - **プロキシツールを用いた方法（Burp Suite等）:** 最も基本的なアプローチは、アプリのHTTPS通信をプロキシ経由で中継し復号する方法です。Burp Suiteなどのプロキシは自前のCA証明書を発行しTLSハンドシェイクの中間者（MiTM）となります。通常、アプリ側がそのCA証明書を信頼すれば通信を傍受できます ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=need%20to%20use%20an%20intercepting,provided%20by%20our%20intercepting%20proxy))。具体的には、BurpのCA証明書をデバイスにインストールして信頼済みに追加し（後述の手順）、アプリのトラフィックをPC上のプロキシに転送します。ピンニングが **無効** であればこれだけで通信内容を取得できますし、アプリコードや動作を変更しないため手法としてはシンプルで安全です ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=Technique%201%20%E2%80%93%C2%A0Adding%20a%20Custom,to%20the%20User%20Certificate%20Store))。しかし近年のAndroidでは**ユーザ追加のCA証明書をデフォルトで信用しない**（Android 7以降のデフォルト設定）ため、単に証明書を追加しただけではプロキシを信頼させられない場合があります ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=By%20default%2C%20secure%20connections%20,domain%20customization))。さらに証明書ピンニングが実装されている場合、たとえOSにプロキシのCAをインストールしても、**アプリはあらかじめ埋め込まれた特定の証明書と一致しない限り接続を拒否**します ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=The%20developer%20configures%20SSL%20pinning,the%20pinned%20certificate%20match)) ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=apps%20will%20terminate%20the%20connection,provided%20by%20our%20intercepting%20proxy))。そのためプロキシツール単体では不十分なケースが多く、次のような追加手段が必要になります。  
   - **フック技術を用いた方法（Frida等）:** フックとは、プログラム実行中に特定の関数やメソッドの動作を書き換える技術です。動的解析フレームワークのFridaを利用すると、アプリの実行時メモリにスクリプトを注入して証明書検証の部分だけを無効化することができます ([Bypassing Certificate Pinning on Android Apps Using Frida: A Step-by-Step Guide](https://approov.io/blog/how-to-bypass-certificate-pinning-with-frida-on-an-android-app#:~:text=Today%20I%20will%20show%20how,app%20has%20implemented%20certificate%20pinning))。例えば、Javaの`X509TrustManager`や`SSLContext.init()`メソッドをフックして常に検証をスキップさせたり、アプリ内のピン留めされた証明書情報を強制的にこちらの用意した証明書に差し替えることが可能です ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=%E5%8C%96SSLContext%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8frida%E5%8A%AB%E6%8C%81SSLContext)) ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=SSLContext.init%28%29...))。フック系の手法には、Frida以外にもXposedフレームワーク上で動作するモジュール（Android用のJustTrustMeやSSL Unpinningモジュール等）がありますが、現在は非改造デバイスでも動的アタッチできるFridaが主流です。**利点**として、アプリをリパッケージすることなく実行時に一時的に挙動を変えられるため、テスト後に元の状態に戻しやすく汎用的です。また公開済みの汎用スクリプト ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=Image%3A%20image%20https%3A%2F%2Fcodeshare.frida.re%2F%40akabe1%2Ffrida,frida))やObjectionなどのツールを使えば、コードを書かずとも多くのアプリでピンニングを迅速に無効化できます ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=SSL%20Pinning%20Bypass%20with%20Objection))。**欠点**としては、フックのためにデバッグ権限が必要な点です。デバイスをroot化するかデバッグビルドのアプリを用意する、もしくはFrida-Gadgetと呼ばれるライブラリをアプリに埋め込む（これは結局APK改変にあたります）などの準備が必要になります ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=This%20type%20of%20interference%20use,functionality%20without%20rooting%20a%20device)) ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=that%20requires%20rooting%20a%20device,modify%20the%20target%20app%E2%80%99s%20code))。さらに高度なアプリではフック自体を検知・阻止するタンパープルーフ（改ざん検知）やroot検知機構があるため、場合によってはそれらのバイパスも並行して行う必要があります。  
   - **アプリの改変（リパッケージやsmaliコード編集）:** ソースコードに近いレベルで直接ピンニング処理を取り除く方法です。リバースエンジニアリングツール（例えばJADXやapktool）を用いて対象アプリを解析し、ピンニングの実装箇所を見つけて書き換えます。**静的解析**によってピンニング方法を特定し、該当するチェック処理を無効化するパターンです。例えば、証明書のSHA-256ハッシュ値をハードコーディングしている場合、その値を自分のプロキシ用証明書のハッシュに置き換えることができます ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=Some%20applications%20use%20a%20hardcoded,technique%20for%20implementing%20SSL%20pinning)) ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=2,hash%20via%20the%20following%20command))。あるいは、ネットワークセキュリティ設定(networkSecurityConfig)で独自CAやピンセットを指定している場合、その設定を削除・改変して既存の信頼ストアを使うように変更します ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=,defined%20certificates))。さらに、コード中で検証メソッドを呼び出しているなら、その部分のsmaliコードを改竄して常に成功を返すように書き換えることも可能です。こうした改変後にapkを再パッケージ・再署名し直してインストールすれば、ピンニングが除去された状態でアプリを動作させられます ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=,a%20Keystore))。**利点**として、一度改造したapkを用意すれば以降何度でも通信を解析でき、フックのように毎回スクリプトを仕込む手間がありません。デバイス側の特殊な準備（root化など）も不要で、改変apkをインストールできれば動作します。**欠点**は、解析とパッチに高度なリバースエンジニアリングの知識を要する点です。対象アプリの難読化が強い場合や独自実装の場合、改変箇所を見つけるのに時間を要します。また改変apkは公式の署名とは異なるため、一部のアプリ（特に配信プラットフォームと連携するもの）は動作しなくなったり、サーバ側で拒否されるリスクもあります。改変行為自体が利用規約に抵触する可能性もあるため、テスト目的でのみ内部利用すべき手法です。

3. **具体的なバイパス手法**  
   - **FridaやObjectionを使ったバイパス手順:** まずフック方式の具体例として、Fridaを利用したSSLピンニングバイパスの手順を解説します。基本的な流れは「デバイス環境準備」→「Fridaスクリプトの実行」→「プロキシで傍受確認」です。デバイスはエミュレータ（root化済みが便利）か実機ならroot化端末を用います ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=,Emulator))。PC側にFridaツール一式（`frida-server`及びPython用のfrida-tools、objection等）をインストールし ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=,Python))、Android端末上でFridaサーバを起動できるようにします。例えばエミュレータの場合、`adb push`でFridaサーバのバイナリを`/data/local/tmp`に配置し、実行権限を与えてバックグラウンド起動します ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=Before%20injecting%20our%20script%2C%20we,server.Run%20the%20following%20command)) ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=Next%2C%20we%E2%80%99ll%20give%20the%20following,server%20binary))。同時に、Burp SuiteなどプロキシのCA証明書をDER形式で端末にコピーしておきます（例: `/data/local/tmp/cert-der.crt`） ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=,Certificate))。準備が整ったら、公開されている汎用のSSLピンニング無効化スクリプト（JavaScript）を取得し端末に置きます ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=%2F%2A%20Android%20SSL%20Re,pier)) ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=setTimeout%28function%28%29%7B%20Java.perform%28function%20%28%29%7B%20console.log%28,Pinning))。あとはPC側からFridaクライアントを使い、対象アプリに先ほどのスクリプトをインジェクションします。コマンド例: `frida -U -f <パッケージ名> -l fridascript.js --no-pause` ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=1,to%20bypass%20SSL%20pinning))。`-U`はUSB接続デバイス指定、`-f`はアプリ起動、`-l`はスクリプト読み込み、`--no-pause`はスクリプト注入後にアプリを一時停止しないオプションです ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=ssl.js%20%3D))。実行するとコンソール上にスクリプトからのログが次々と出力されます。例えば汎用スクリプトv0.2では「Cert Pinning Bypass...」「Loading our CA...」等のメッセージが表示され、内部で**BurpのCA証明書を読み込みカスタムTrustManagerを生成した**ことが確認できます ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=%2F%2F%20Load%20CAs%20from%20an,X.509)) ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=var%20certInfo%20%3D%20Java,%2B%20certInfo.getSubjectDN))。 ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981))Fridaスクリプトを実行したコンソール画面の一部。PortSwigger（Burp Suite）のCA証明書を読み込み、SSLContextをフックしてアプリにカスタムTrustManagerを適用しているログが表示されている ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=%2F%2F%20Load%20CAs%20from%20an,X.509)) ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=SSLContext.init.overload%28,))。最後に「SSLContext initialized with our custom TrustManager!」と出力されればスクリプト注入成功です。スクリプトは証明書検証を強制的に信頼させるよう働くため、その状態でアプリが通信する先は全てこちらのプロキシ証明書でTLS接続されます ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=Step%205,Suite))。実際、Fridaによるピンニング無効化後にターゲットアプリ（ここでは例としてTwitterアプリ）を動かすと、Burp SuiteでHTTPS通信を傍受できるようになります ([SSL Pinning Bypass for Android using Frida - Redfox Security - Pen Testing Services](https://redfoxsec.com/blog/ssl-pinning-bypass-android-frida/#:~:text=Image%3A%20ssl%20pinning%20bypass))。このときFridaサーバとスクリプトは動作し続けている必要がありますが、ユーザから見たアプリの挙動は変わりません。 ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981))Fridaスクリプト適用後、Burp Suiteで対象アプリのHTTPSリクエストを傍受した様子。左側はBurpのHTTP履歴で、`api.tuniu.com`（中国の旅行アプリ）のAPI通信内容が平文で表示されている。赤枠で示した電話番号フィールド（\"tel\": \"008617612512345\"）は、右側のモバイルアプリ画面でユーザが入力した番号と一致しており、SSLピンニングのバイパスによって通信が解読できていることを示す ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=Image)) ([利用Frida绕过Android App（apk）的SSL Pinning-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2201981#:~:text=%E4%B8%80%E6%97%A6frida%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F%EF%BC%8C%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E9%87%8F%E9%83%BD%E5%B0%86%E8%A2%ABburp%E6%8B%A6%E6%88%AA))。  
     
     Objectionツールを使えば上述のFrida処理を自動化することも可能です。ObjectionはFridaのラッパーで、デバイスにFridaサーバが動いていれば`objection -g <パッケージ名> explore`で対話シェルに入り、コマンド一発でSSLピンニングを無効化できます ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=3,objection%20and%20explore%20the%20application)) ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=9,Frida))。例えばシェル内で`android sslpinning disable`と入力すると内部で適切なフックが実行され、「SSL Pinning の無効化に成功した」旨のメッセージが出ます ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=objection%20%E2%80%94%20g%20package_name%20explore))。その後アプリの通信を行えば、同様にプロキシで内容を確認できます ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=5,captured%20in%20the%20burp%20suite)) ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=2,captured%20in%20the%20burp%20suite))。Objectionは他にもroot検知の回避や動的メモリダンプなど多彩な機能がありますが、SSLピンニング解除は代表的な用途の一つです。

   - **Burp Suiteでの設定方法と証明書のインストール:** プロキシ方式で傍受を行うには、まずBurp側のCA証明書を端末に導入して信頼させる必要があります。Burp Suiteの場合、メニューの「Proxy」タブからCA証明書をDER形式でエクスポートできます ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=1,Export%20Certificate%20in%20DER%20format))。これをAndroid端末にコピーし、設定メニューの「セキュリティ＞証明書のインストール」からユーザ証明書として追加することで、**「ユーザが追加したCA」を信頼ストアに登録**できます。Android 6以下をターゲットとするアプリなら、この手順でユーザストアに登録されたCAも通信で信用してくれるため、ピンニングが無ければそのまま傍受が可能です ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=Android%20has%20two%20built,installed%20CAs%29.%20From%20developer.android.com)) ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=What%20does%20this%20mean%20to,xml%20file))。しかしAndroid 7以降をターゲットとするアプリではデフォルト設定でユーザ追加CAを無視するため、このままでは依然として証明書エラーになります ([Four Ways to Bypass Android SSL Verification and Certificate Pinning](https://www.netspi.com/blog/technical-blog/mobile-application-pentesting/four-ways-bypass-android-ssl-verification-certificate-pinning/#:~:text=What%20does%20this%20mean%20to,xml%20file))。この問題への対処法がいくつかあります。ひとつは**エミュレータやroot端末を使い、証明書をシステム証明書ストアに入れてしまう方法**です ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=Lets%20focus%20on%20the%20first,manually%20by%20the%20following%20method)) ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=Export%20Burp%20CA%20Certificate))。具体的には、DER形式のBurp証明書をPEMに変換し（`openssl x509 -inform DER -in cacert.der -out cacert.pem`）、さらにそのPEMのsubject hash値をファイル名にして`.0`拡張子を付け（`openssl x509 -in cacert.pem -noout -subject_hash_old`でハッシュ取得）、`/system/etc/security/cacerts/`にコピーします ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=Export%20Burp%20CA%20Certificate)) ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=1,convert%20DER%20to%20PEM%2C%20then))。こうすることで端末を再起動した際にシステムCAとして認識され、アプリもシステムCAとして信頼するようになります ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=2,accept%20it%20as%20trusted%20CA))。もちろんこの操作にはroot権限が必要ですが、エミュレータであれば容易に実現できます。もう一つの方法は**アプリ側のネットワークセキュリティ設定を変更する方法**です。後述するAPK改変手法になりますが、AndroidManifest.xmlで`android:networkSecurityConfig`に独自設定が指定されている場合、そこに`<base-config>`や`<domain-config>`が記述されています ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=))。この中に`<trust-anchors>`の指定があればユーザ証明書を受け入れない設定になっている可能性が高いです。ネットワークセキュリティ設定XML（res/xml配下）を解析し、必要に応じて`<certificates src="user" />`を追加することでユーザストアの証明書も信頼させることができます ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=,defined%20certificates))。例えばOWASPのガイドでも、ユーザ追加証明書を信頼させることでSSLピンニングを迂回するテクニックが紹介されています ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=,defined%20certificates))。以上の証明書設定が完了したら、Burp側でプロキシを有効にして待ち受けます。端末のWi-Fiプロキシ設定でBurpインスタンスのIPアドレスとポート（デフォルトは8080）を指定するか、adbコマンドで端末全体のトラフィックをリダイレクトする方法（iptablesを使ったtransparent proxy設定）もあります ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=Steps%20To%20Bypass%20SSL%20pinning,via%20IPtables%20Traffic%20Forwarding)) ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=4,using%20following%20command))。あとは対象アプリを起動し操作することで、BurpのProxyタブにリクエストが記録されます。ピンニングがなければこれで通信内容を確認でき、ピンニングがあってFrida等で無効化した場合も同様に確認できます。前述の画像のように、正しく設定すればアプリからサーバへのHTTPSリクエストやレスポンスをBurp上で閲覧・解析できます。さらにBurpの拡張機能やRepeater機能を使って、盗聴だけでなく通信の改ざんや再送信テストも可能になります。なお、HTTPS通信の傍受行為は慎重に行う必要があります。他のアプリの通信も迂闊に傍受すると個人情報を扱う恐れがあるため、テスト時は対象アプリ以外を終了する、あるいは専用のテスト用デバイス・エミュレータで実施することが望ましいでしょう。

   - **Androidアプリのデコンパイルと改変（APKToolやJADXの利用）:** 最後に、APKを逆コンパイルして直接ピンニング実装を改変する手法の具体例です。この手法では対象アプリのコード（または設定ファイル）内にハードコードされたピンニング情報を探し出し、書き換えることで恒久的にバイパスを実現します。まず[JADX](https://github.com/skylot/jadx)などのデコンパイラでAPKを読み込み、ソースコードやリソースファイルを調査します。例えば通信関連のクラスや設定として、`CertificatePinner`や`TrustManager`、`networkSecurityConfig`といったキーワードを検索します ([How-to bypass SSL Pinning on Android using JadX](https://www.cyberlands.io/sslpinningbypassandroid#:~:text=2,to%20SSL%20Pinning%20in%20it)) ([How-to bypass SSL Pinning on Android using JadX](https://www.cyberlands.io/sslpinningbypassandroid#:~:text=5,match%2C%20an%20exception%20is%20generated))。具体的なケースとして、OkHttp3ライブラリを使ったピンニング実装では、`CertificatePinner`クラスの`add(String domain, String ... sha256Pins)`メソッドでホスト毎に証明書ハッシュ(ピン)を登録しています ([How-to bypass SSL Pinning on Android using JadX](https://www.cyberlands.io/sslpinningbypassandroid#:~:text=5,match%2C%20an%20exception%20is%20generated))。JADX上で該当クラスを確認し、ターゲットドメインとハッシュ値がどこで設定されているかを特定します ([How-to bypass SSL Pinning on Android using JadX](https://www.cyberlands.io/sslpinningbypassandroid#:~:text=Image))。多くの場合、ピン留め用のハッシュ値（base64エンコードされたSHA-256など）がソース中に文字列リテラルとして埋め込まれているため、それを見つけ出します ([How-to bypass SSL Pinning on Android using JadX](https://www.cyberlands.io/sslpinningbypassandroid#:~:text=Image)) ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=The%20certificate%20of%20my%20BurpSuite,for%20the%20API%20is%20fkwx01%E2%80%A6))。次に[APKTool](https://ibotpeaches.github.io/Apktool/)を使用してAPKをデコードし、smaliコードやリソースXMLを編集可能な状態に展開します。先ほど特定したピンningハッシュがどのsmaliファイルに含まれるかを探し、その値を**プロキシ側の証明書ハッシュ値に置換**します ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=So%2C%20we%20can%20simply%20replace,hash%20and%20reinstall%20the%20application)) ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=2,hash%20via%20the%20following%20command))。Burp Suiteの証明書ハッシュは、opensslコマンドで取得できます（例：`openssl x509 -in burp.crt -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64` でSHA-256ハッシュを算出）。実例として、あるアプリではログ出力から「アプリ内にピン留めされた証明書のハッシュ（例: fkwx01...）とBurp証明書のハッシュ（例: u8Q1BC...）が異なる」と判明したため ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=Logs%20for%20SSL%20pinning%20failure))、対応するsmaliコード上のハッシュ値をBurpのものに書き換えました ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=SSL%20pinning%20code%20found))。また別の例では、AndroidManifest.xmlで指定されていた`networkSecurityConfig`リソース内からピン設定（証明書のSHA-256フィンガープリント）が記述された部分を削除することでピンニングを無効化できたケースもあります ([9 Different Ways To Bypass SSL Pinning In Android | by Vaishali Nagori | Medium](https://medium.com/@vaishalinagori112/9-different-ways-to-bypass-ssl-pinning-in-android-2d8c7f81b837#:~:text=Some%20applications%20define%20the%20pinning,and%20bypass%20the%20SSL%20pinning))。このように必要な改変を施したら、apktoolで再ビルドします（`apktool b <デコードフォルダ> -o <改変APK>`）。ビルド後のAPKは元の署名が使えないため、自分で新しいキーストアを作成して署名します（`jarsigner`コマンドや[Uber APK Signer](https://github.com/patrickfav/uber-apk-signer)等を利用）。例えば`keytool -genkeypair -alias testkey -keystore test.keystore -keyalg RSA -keysize 2048 -validity 10000`で鍵を作成し、`jarsigner -keystore test.keystore 改変APKファイル testkey`で署名します ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=,a%20Keystore))。最後に署名付きAPKを端末にインストールし（既存の同名アプリがある場合はアンインストールしてからインストール）、改変内容が反映されたかテストします。ピンニングが正しく無効化されていれば、改変後のアプリを起動してBurpプロキシにアクセスを集めるだけで、通信の内容を閲覧できるはずです。 ([RevEnge! Reverse Engineering android apps to bypass SSL pinning for mobile app pen-testing | by Shayan Ahmed Khan | Medium](https://medium.com/@shaddy43/revenge-reverse-engineering-android-apps-to-bypass-ssl-pinning-for-mobile-app-pen-testing-eeef2ce22682#:~:text=Patching%20in%20smali))実際にピン留めハッシュを書き換えた改造APKを用いて再度ログイン操作を行ったところ、Burp Suite上で全ての通信がインターセプトされ、SSLピンニングのバイパスに成功したことが確認されています。改変APK方式は確実ですが手間がかかるため、まずはFridaフックやObjectionによる一時的な無効化を試し、どうしても動作しない特殊なケース（ネイティブライブラリ内でピンニング実装がある等 ([Android证书绑定绕过研究(一)_proxygen绕过-CSDN博客](https://blog.csdn.net/qq_30135181/article/details/119654800#:~:text=)) ([Android证书绑定绕过研究(一)_proxygen绕过-CSDN博客](https://blog.csdn.net/qq_30135181/article/details/119654800#:~:text=1,handlers%2Flibc.so%2Fclose.js))）に対して最終手段として適用する流れが一般的です。なお、逆コンパイルや改変作業の際は著作権や利用規約にも注意し、社内テストや学習目的の範囲に留めるようにしてください。バイパスに成功した暁には、開発者視点ではアプリの通信内容を詳細に解析できるようになりますが、それは同時に攻撃者にも同じことが可能になることを意味します。ピンニングは万能ではなく、ここで紹介したような多様な手法で突破され得るため、**本来守るべき機密データは通信経路とは別のレイヤでも保護する（二重の暗号化やサーバ側検証など）**ことが重要です ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=Understand%20how%20the%20application%20is,end%20encryption%20prevents%20request%20tampering)) ([Tricks-Pentest-Android-and-iOS-Applications/client_side_protections_android.md at main · rodolfomarianocy/Tricks-Pentest-Android-and-iOS-Applications · GitHub](https://github.com/rodolfomarianocy/Tricks-Pentesting-Android-and-iOS-Applications/blob/main/client_side_protections_android.md#:~:text=If%20end,end%20encryption%20prevents%20request%20tampering))。今回の解説を通じ、ピンニング実装の堅牢化や追加対策を検討するきっかけになれば幸いです。

